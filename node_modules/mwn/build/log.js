/**
 * semlog
 * A semantic logger that colors and formats messages automatically according to the content
 *
 * Adapted from https://github.com/Fannon/semlog
 *
 * @author Simon Heimler
 * @author Siddharth VP - removed use of globals and adapted to TypeScript,
 * also removed some unnecessary features like in-memory log retention
 * and keeping track of statistics
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.humanDate = exports.getDateArray = exports.pad = exports.colorize = exports.error = exports.debug = exports.message = exports.log = exports.updateLoggingConfig = exports.logConfig = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const chalk = require('chalk');
const prettyjson = require('prettyjson');
exports.logConfig = {
    printYaml: false,
    printDebug: true,
    printVerbose: true
};
function updateLoggingConfig(options) {
    Object.assign(exports.logConfig, options);
}
exports.updateLoggingConfig = updateLoggingConfig;
/**
 * Custom Logging function
 *
 * Writes Logs to console, stringifies objects first
 *
 * @param obj
 */
function log(obj) {
    if (obj && obj instanceof Error) {
        error(obj);
    }
    else if (obj && typeof obj === 'object') {
        debug(obj);
    }
    else {
        message(obj);
    }
}
exports.log = log;
// Functions below are exported only for unit testing
function message(msg) {
    if (typeof msg !== 'string') {
        try {
            msg = '' + JSON.stringify(msg);
        }
        catch (e) {
            msg = '[E] [Logger] Could not stringify given parameter';
        }
    }
    msg = colorize(msg);
    if (msg.trim && msg.trim().length > 0) {
        msg = chalk.gray('[' + humanDate() + '] ') + msg;
    }
    if (!exports.logConfig.printVerbose && msg.indexOf('[V]') >= 0) {
        // Supressing output of verbose message
    }
    else if (!exports.logConfig.printDebug && msg.indexOf('[D]') >= 0) {
        // Supressing output of debug message
    }
    else {
        console.log(msg);
    }
}
exports.message = message;
/**
 * Prints out debugging information for the current model object
 * @param obj
 */
function debug(obj) {
    if (exports.logConfig.printYaml) {
        // Print YAML
        let options = {
            keysColor: 'white',
            dashColor: 'white',
            stringColor: 'yellow',
            numberColor: 'blue'
        };
        console.log(chalk.gray('---\n') + prettyjson.render(obj, options));
    }
    else {
        // Print indented JSON
        let msg = JSON.stringify(obj, null, 4);
        console.log(chalk.gray(msg));
    }
}
exports.debug = debug;
/**
 * Prints errors
 * @param obj
 */
function error(obj) {
    console.error(chalk.red('[E] ' + obj.message));
    console.log(chalk.gray(JSON.stringify(obj, null, 4)));
    if (obj.stack) {
        console.log(chalk.gray(obj.stack));
    }
}
exports.error = error;
/**
 * Colors the messages by searching for specific indicator strings
 *
 * @param {string} msg
 * @returns {string}
 */
function colorize(msg) {
    let colorMap = {
        '[E]': 'red',
        '[W]': 'yellow',
        '[?]': 'yellow',
        '[S]': 'green',
        '[i]': 'blue',
        '[+]': 'green',
        '[-]': 'red',
        '[C]': 'cyan',
        '[U]': 'grey',
        '[=]': 'grey',
        '[/]': 'grey',
        '[V]': 'magenta',
        '[D]': 'magenta',
        '[T]': 'magenta',
        '[TODO]': 'magenta' // TO-DO
    };
    for (let [code, color] of Object.entries(colorMap)) {
        if (msg && msg.indexOf && msg.startsWith(code)) {
            return chalk[color](msg);
        }
    }
    return msg;
}
exports.colorize = colorize;
/**
 * Pad a number with n digits
 *
 * @param {number} number   number to pad
 * @param {number} digits   number of total digits
 * @returns {string}
 */
function pad(number, digits) {
    return new Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number;
}
exports.pad = pad;
/**
 * Returns an array with date / time information
 * Starts with year at index 0 up to index 6 for milliseconds
 *
 * @param {Date} date   Optional date object. If falsy, will take current time.
 * @returns {Array}
 */
function getDateArray(date) {
    date = date || new Date();
    return [
        date.getFullYear(),
        pad(date.getMonth() + 1, 2),
        pad(date.getDate(), 2),
        pad(date.getHours(), 2),
        pad(date.getMinutes(), 2),
        pad(date.getSeconds(), 2),
        pad(date.getMilliseconds(), 2)
    ];
}
exports.getDateArray = getDateArray;
/**
 * Returns nicely formatted date-time
 * @example 2015-02-10 16:01:12
 *
 * @param {object} [date]
 * @returns {string}
 */
function humanDate(date) {
    date = date || new Date();
    let d = getDateArray(date);
    return d[0] + '-' + d[1] + '-' + d[2] + ' ' + d[3] + ':' + d[4] + ':' + d[5];
}
exports.humanDate = humanDate;
//# sourceMappingURL=log.js.map